import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,d as e,a as t,f as i}from"./app-tlQxsxoM.js";const o="/assets/IoC原理-05eIF9hI.png",l="/assets/DefaultListableBeanFactory继承关系-GTlbGfsg.png",p="/assets/ApplicationContext继承关系-awbBrOaR.png",c="/assets/ApplicationContext实现类-y619SG_i.png",r="/assets/ApplicationContext实现类2-41zrxEd_.png",u="/assets/IoC流程1-fiW2Lze7.png",d="/assets/IoC流程2-JMLCe-oY.png",k="/assets/IoC流程3-efimA1Rq.png",m="/assets/Ioc的整体流程-5k78XulN.png",v={},b=t("p",null,"传统的Java程序代码通常将对象的构建、接口的实现以及业务的实现紧密的耦合在一起，不利于代码的扩展性。为了解决了传统Java程序代码的紧密耦合问题。Spring提出了IoC（Inversion of control：即控制反转）的设计思想，将原本在程序中手动创建对象的控制权、对象之间的相互依赖关系交给 IoC 容器来管理，并由IoC容器完成对象的依赖注入。这样即实现了对象之间的松耦合，使程序的的可读性和扩展性大大提升，又在可以很大程度上简化应用的开发。",-1),B=i('<h2 id="_1-ioc与di思想的提出" tabindex="-1"><a class="header-anchor" href="#_1-ioc与di思想的提出" aria-hidden="true">#</a> 1.IoC与DI思想的提出</h2><ul><li>Spring 通过IoC容器来管理所有Java对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由IoC容器管理的Java对象称为Spring Bean，Spring使用工厂设计模式，通过BeanFactory的方式已经实现的&quot;控制反转&quot;，将Bean的创建权交给了BeanFactory。</li></ul><figure><img src="'+o+'" alt="IoC原理" tabindex="0" loading="lazy"><figcaption>IoC原理</figcaption></figure><ul><li>Spring创建对象的过程中，将对象属性、依赖关系通过配置进行注入。这被称为DI（Dependency Injection）依赖注入。常见的两种注入方式为：Set方式注入和构造函数注入。</li><li>IoC与DI的关系： <ul><li>第一种观点是IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系。</li><li>第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式。</li></ul></li></ul><h2 id="_2-beanfactory详解" tabindex="-1"><a class="header-anchor" href="#_2-beanfactory详解" aria-hidden="true">#</a> 2.BeanFactory详解</h2><p>​ 上面讲到，Spring IoC将Bean的控制权交给BeanFactory进行管理和依赖注入，BeanFactory直译为Bean的生产工厂。BeanFactory是Spring最高级抽象的接口，是工厂模式的实现，允许通过创建和检索对象，即生产Bean。</p><ul><li>BeanFactory支持单例模型（singleton）和原型模型（prototype）两种对象对象模型管理对象。 <ol><li>单例模型：Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中，进行全局共享。每次获取Bean时都是从单例池中获取相同的Bean实例；</li><li>原型模型：Spring容器初始化时不会创建Bean实例，当每次获取Bean时才会实例化Bean，每次获取Bean都会创建一个新的Bean实例。</li></ol></li></ul><blockquote><p>BeanFactory默认Bean管理模型为单例模式。</p></blockquote><ul><li>BeanFactory的继承关系如下图所示，BeanFactory有三个重要的子类：ListableBeanFactory、HierarchicalBeanFactory、AbstractAutowireCapbleBeanFactory。DefaultListableBeanFactory是其最终的实现，实现了所有的接口。 <ol><li>ListableBeanFactory接口，表示Bean列表化</li><li>HierarchicalBeanFactory接口，表示Bean继承关系</li><li>AbstractAutowireCapbleBeanFactory接口，定义了Bean的自动装配规则</li></ol></li></ul><figure><img src="'+l+`" alt="DefaultListableBeanFactory继承关系" tabindex="0" loading="lazy"><figcaption>DefaultListableBeanFactory继承关系</figcaption></figure><blockquote><p>这三个接口共同定义了Bean的集合、Bean之间的关系以及Bean的行为</p></blockquote><p>BeanFactory加载配置文件的示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">DefaultListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建读取器</span>
<span class="token class-name">XmlBeanDefinitionReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanDefinitionReader</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//加载配置文件</span>
reader<span class="token punctuation">.</span><span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span><span class="token string">&quot;beans.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ApplicationContext称为Spring容器，内部封装了BeanFactory，比BeanFactory功能更丰富更强大，ApplicationContext除了继承了BeanFactory外，还继承了ApplicationEventPublisher（事件发布器）、ResouresPatternResolver（资源解析器）、MessageSource（消息资源）等。但是ApplicationContext的核心功能还是BeanFactory。其继承关系如下图 ：</li></ul><figure><img src="`+p+'" alt="ApplicationContext继承关系" tabindex="0" loading="lazy"><figcaption>ApplicationContext继承关系</figcaption></figure><ul><li>ApplicationContext和BeanFactory之间的关系：</li></ul><ol><li>BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为Spring容器；</li><li>ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的 API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；</li><li>Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且 ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系。</li><li>Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。</li></ol><p>​ 在Spring环境中，ApplicationContext常用的实现类为：ClassPathXmlApplicationContext、FileSystemXmlApplicationContext和AnnotationConfigApplicationContext。</p><figure><img src="'+c+'" alt="ApplicationContext实现类" tabindex="0" loading="lazy"><figcaption>ApplicationContext实现类</figcaption></figure><ol><li>ClassPathXmlApplicationContext：加载类路径下的xml配置的ApplicationContext</li><li>FileSystemXmlApplicationContext：加载磁盘路径下的xml配置的ApplicationContext</li><li>AnnotationConfigApplicationContext：加载注解配置类的ApplicationContext</li></ol><p>​ 在Spring Web环境中，ApplicationContext常用的实现类为：XmlWebApplicationContext和AnnotationConfigWebApplicationContext。</p><figure><img src="'+r+`" alt="ApplicationContext实现类" tabindex="0" loading="lazy"><figcaption>ApplicationContext实现类</figcaption></figure><p>​ XmlWebApplicationContext：web环境下，加载类路径下的xml配置的ApplicationContext。AnnotationConfigWebApplicationContext：web环境下，加载磁盘路径下的xml配置的ApplicationContext。</p><p>ApplicationContext加载配置文件的示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;applicationContext.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">UserDao</span> userDao <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;userDao&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-bean的生产流程详解" tabindex="-1"><a class="header-anchor" href="#_3-bean的生产流程详解" aria-hidden="true">#</a> 3.Bean的生产流程详解</h2><ul><li><p>Spring容器在进行初始化时，会将xml配置的&lt;bean&gt;标签的信息封装成一个BeanDefinition对象，然后将所有的BeanDefinition存储到一个名为beanDefinitionMap的Map集合中，Spring框架再对beanDefinitionMap进行遍历，使用反射创建Bean实例对象，创建好的Bean对象存储在一个名为singletonObjects的Map集合中，当调用getBean方法时则最终从该Map集合中取出Bean实例对象返回。</p></li><li><p>DefaultListableBeanFactory对象内部维护着一个Map集合用于存储封装好的BeanDefinitionMap，Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，通过反射构造方法或调用指定的工厂方法生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对应的Bean的实例化操作，然后将Bean存储到单例池singletonObjects中，在DefaultListableBeanFactory的父类DefaultSingletonBeanRegistry中，维护着singletonObjects。Bean实例化的基本流程如下图所示。</p></li></ul><figure><img src="`+u+`" alt="IoC流程1" tabindex="0" loading="lazy"><figcaption>IoC流程1</figcaption></figure><ul><li><p>Spring提供后处理器，我们可以介入到Bean的整个实例化流程中来，以达到动态注册BeanDefinition、动态修改BeanDefinition以及动态修改Bean的作用。Spring主要有两种后处理器：</p><ol><li><p>BeanFactoryPostProcessor：Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行；</p></li><li><p>BeanPostProcessor：Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行。</p></li></ol></li><li><p>Bean工厂后处理器（BeanFactoryPostProcessor）是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>

        <span class="token comment">//获得UserDao定义对象</span>

        <span class="token class-name">BeanDefinition</span> userDaoBD <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span>“userDao”<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//修改class  </span>

        userDaoBD<span class="token punctuation">.</span><span class="token function">setBeanClassName</span><span class="token punctuation">(</span><span class="token string">&quot;org.example.Dao.UserDaoImpl&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//修改初始化方法</span>

        <span class="token comment">//userDaoBD.setInitMethodName(methodName);</span>

        <span class="token comment">//修改是否懒加载</span>

        <span class="token comment">//userDaoBD.setLazyInit(true); }</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>postProcessBeanFactory 参数本质就是 DefaultListableBeanFactory，拿到BeanFactory的引用，自然就可以 对beanDefinitionMap中的BeanDefinition进行操作了。</p></li><li><p>Spring 提供了一个BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor专门用于BeanDefinition的注册操作</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor2</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> configurableListableBeanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> beanDefinitionRegistry<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>

    	<span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    	beanDefinition<span class="token punctuation">.</span><span class="token function">setBeanClassName</span><span class="token punctuation">(</span><span class="token string">&quot;org.example.Dao.UserDaoImpl2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    	beanDefinitionRegistry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">&quot;userDao2&quot;</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+`" alt="IoC流程2" tabindex="0" loading="lazy"><figcaption>IoC流程2</figcaption></figure><ul><li>Bean后处理器（BeanPostProcessor），Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被Spring自动调用。 BeanPostProcessor的接口定义如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Nullable</span>

    <span class="token comment">//在属性注入完毕，init初始化方法执行之前被回调</span>

    <span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>

    		<span class="token keyword">return</span> bean<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Nullable</span>

<span class="token comment">//在初始化方法执行之后，被添加到单例池singletonObjects之前被回调</span>

    <span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>

   	 		<span class="token keyword">return</span> bean<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+k+`" alt="IoC流程3" tabindex="0" loading="lazy"><figcaption>IoC流程3</figcaption></figure><h2 id="_4-bean的生命周期详解" tabindex="-1"><a class="header-anchor" href="#_4-bean的生命周期详解" aria-hidden="true">#</a> 4.Bean的生命周期详解</h2><ul><li><p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储 到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：</p><ul><li>Bean的实例化阶段：Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的，是否不是延迟加载的，是否不是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化。</li><li>Bean的初始化阶段：Bean创建之后还仅仅是个&quot;半成品&quot;，还需要对Bean实例的属性进行填充、执行一些Aware接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。</li><li>Bean的完成阶段：经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects中去了，即完成了Spring Bean的整个生命周期。</li></ul></li><li><p>Spring Bean的初始化过程涉及如下几个过程：</p><ul><li>Bean实例的属性填充：BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，</li><li>Aware接口属性注入</li><li>BeanPostProcessor的before()方法回调</li><li>InitializingBean接口的初始化方法回调</li><li>自定义初始化方法init回调</li><li>BeanPostProcessor的after()方法回调</li></ul></li><li><p>Spring在进行属性注入时，会分为如下几种情况：</p><ul><li>注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去。</li><li>注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被 注入对象Bean实例（完成整个生命周期）后，在进行注入操作。</li><li>注入双向对象引用属性时，就比较复杂了，涉及了循环依赖问题。</li></ul></li></ul><blockquote><p>Spring提供了三级缓存存储 完整Bean实例 和 半成品Bean实例 ，用于解决循环依赖问题</p></blockquote><p>在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>

    <span class="token comment">//1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span>

    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span>

    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span>

    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解决循环依赖的解决过程描述如下：</strong></p><ol><li>对象A实例化，但尚未初始化，将对象A存储到三级缓存；</li><li>对象A 属性注入，需要对象B，从缓存中获取，没有对象B；</li><li>对象B实例化对象，但尚未初始化，将对象B存储到到三级缓存；</li><li>对象B属性注入，需要对象A，从三级缓存获取对象A，对象A从三级缓存移入二级缓存；</li><li>对象B执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存；</li><li>对象A注入对象B；</li><li>对象A行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存。</li></ol><p>​ Aware接口是一种框架辅助属性注入的一种思想，框架具备高度封装性，我们接 触到的一般都是业务代码，一个底层功能API不能轻易的获取到，如果用到了，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象。</p><h2 id="_5-spring-ioc整体流程总结" tabindex="-1"><a class="header-anchor" href="#_5-spring-ioc整体流程总结" aria-hidden="true">#</a> 5.Spring IoC整体流程总结</h2><figure><img src="`+m+'" alt="Ioc的整体流程" tabindex="0" loading="lazy"><figcaption>Ioc的整体流程</figcaption></figure><ol><li>BeanDefinition阶段：1.读取配置封装BeanDefinition，2.将BeanDefinition存储到BeanDefinitionMap，3.执行Bean工厂后处理器</li><li>Bean实例化阶段：Bean实例化了，但是未执行属性填充等生命周期过程，所以是个“半成品”。</li><li>Bean初始化阶段：该阶段对Bean进行生命周期过程执行，Spring大多数功能增强，例如注解解析、AOP都是在此完成的。</li><li>Bean存储阶段：实例化好并初始化好的Bean存储到单例池singletonObjects中。</li></ol>',47);function g(f,y){return a(),s("div",null,[b,e(" more "),B])}const D=n(v,[["render",g],["__file","spring2.html.vue"]]);export{D as default};
